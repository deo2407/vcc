blob 3309
#include "add.h"
#include "object.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <openssl/sha.h>

void binary_to_hex(const unsigned char *buf, int len, char *out) {
    const char hex[] = "0123456789abcdef";
    for (int i = 0; i < len; i++) {
        out[i * 2] = hex[(buf[i] >> 4) & 0xF];
        out[i * 2 + 1] = hex[buf[i] & 0xF];
    } 
    out[len * 2] = '\0';
}

void add_to_index(const char *filename, const char *hash) {
    FILE *fp = fopen(".vcc/index", "ab");
    if (fp == NULL) {
        fprintf(stderr, "index file doesn't exist!\n");
        return;
    }
    fprintf(fp, "%s %s\n", filename, hash);

    fclose(fp);
}

void add_obj(const char *filename, char *contents, long size, obj_type_t type) {
    // create the hash for the given object
    unsigned char hash_bin[SHA_DIGEST_LENGTH];
    char hash[SHA_DIGEST_LENGTH * 2];
    SHA1((unsigned char *)contents, size, hash_bin);
    binary_to_hex(hash_bin, SHA_DIGEST_LENGTH, hash);

    if (type == BLOB)
        printf("generated hash for file %s: %s\n", filename, hash);

    // serialize it
    char *serialized = serialize_obj(contents, size, type);

    // store the file
    char hash_filename[128];
    snprintf(hash_filename, sizeof hash_filename, ".vcc/objects/%s", hash);

    FILE *fp = fopen(hash_filename, "wb");
    if (fp == NULL) {
        fprintf(stderr, "could not create object file with hash %s\n", hash);
        return;
    }
    fprintf(fp, "%s", serialized);

    if (type == BLOB)
        add_to_index(filename, hash);

    free(serialized);
    fclose(fp);
}

void add_file(const char *filename) {
    FILE *fp = fopen(filename, "rb");

    if (fp == NULL) {
        fprintf(stderr, "could not find file %s\n", filename);
        return;
    }

    fseek(fp, 0L, SEEK_END);
    long length = ftell(fp);
    rewind(fp);

    char* buffer = (char*)malloc(length + 1);
    if (!buffer) {
        fclose(fp);
        return;
    }

    size_t bytesRead = fread(buffer, 1, length, fp);
    buffer[bytesRead] = '\0';

    add_obj(filename, buffer, bytesRead, BLOB);
    printf("%s added to storage\n", filename);

    fclose(fp);
    free(buffer);
}

void rec_search(char *dirname) {
    DIR *d = opendir(dirname);
    if (d == NULL) {
        return;
    }
   
    struct dirent *entry;
    // then traverse the directories
    while ((entry = readdir(d)) != NULL) {
        if (entry->d_type == DT_DIR) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0
                    || strcmp(entry->d_name, ".vcc") == 0 || strcmp(entry->d_name, ".git") == 0) 
                continue;

            char subpath[PATH_MAX];
            snprintf(subpath, sizeof subpath, "%s/%s", dirname, entry->d_name);
            rec_search(subpath);
        }
        else if (entry->d_type == DT_REG) {
            char filepath[PATH_MAX];
            snprintf(filepath, sizeof filepath, "%s/%s", dirname, entry->d_name);
            add_file(filepath);
        }
    }
    closedir(d);
}

void add_all() {
    rec_search("."); 
}

int add(const char *files[], size_t files_len) {
    if (strcmp(files[2], ".") == 0) {
        add_all();
        return 0;
    }

    for (int i = 2; i < files_len; i++) {
        add_file(files[i]); 
    }
    return 0;
}

