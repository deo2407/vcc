blob 3154
#include "add.h"
#include "object.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <openssl/sha.h>


void add_to_index(const char *filename, const char *hash) {
    FILE *fp = fopen(".vcc/index", "ab");
    if (fp == NULL) {
        fprintf(stderr, "index file doesn't exist!\n");
        return;
    }
    fprintf(fp, "%s %s\n", filename, hash);

    fclose(fp);
}

void add_tree(char *contents, long size) {
    // serialize tree
    char *serialized = serialize_obj(contents, size, TREE);

    // store the file
    char hash_filename[128];
    generate_hash_filename(contents, size, hash_filename, sizeof hash_filename);

    FILE *fp = fopen(hash_filename, "wb");
    if (fp == NULL) {
        fprintf(stderr, "could not create object file %s\n", hash_filename);
        return;
    }
    fprintf(fp, "%s", serialized);

    free(serialized);
    fclose(fp);
}

void add_file(const char *filename) {
    FILE *fp = fopen(filename, "rb");

    if (fp == NULL) {
        fprintf(stderr, "could not find file %s\n", filename);
        return;
    }

    fseek(fp, 0L, SEEK_END);
    long length = ftell(fp);
    rewind(fp);

    char* buffer = (char*)malloc(length + 1);
    if (!buffer) {
        fclose(fp);
        return;
    }

    size_t bytesRead = fread(buffer, 1, length, fp);
    buffer[bytesRead] = '\0';

    // serialize it
    char *serialized = serialize_obj(buffer, bytesRead, BLOB);

    // store the file
    char hash_filename[128];
    generate_hash_filename(buffer, bytesRead, hash_filename, sizeof hash_filename);
    
    fp = fopen(hash_filename, "wb");
    if (fp == NULL) {
        fprintf(stderr, "could not create object file %s\n", hash_filename);
        return;
    }

    fprintf(fp, "%s", serialized);

    char hash[SHA_DIGEST_LENGTH * 2 + 1];
    generate_hash_filename(buffer, bytesRead, hash, sizeof hash);
    add_to_index(filename, hash);

    free(serialized);
    fclose(fp);

    printf("%s added to storage\n", filename);

    free(buffer);
}

void rec_search(char *dirname) {
    DIR *d = opendir(dirname);
    if (d == NULL) {
        return;
    }
   
    struct dirent *entry;
    // then traverse the directories
    while ((entry = readdir(d)) != NULL) {
        if (entry->d_type == DT_DIR) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0
                    || strcmp(entry->d_name, ".vcc") == 0 || strcmp(entry->d_name, ".git") == 0) 
                continue;

            char subpath[PATH_MAX];
            snprintf(subpath, sizeof subpath, "%s/%s", dirname, entry->d_name);
            rec_search(subpath);
        }
        else if (entry->d_type == DT_REG) {
            char filepath[PATH_MAX];
            snprintf(filepath, sizeof filepath, "%s/%s", dirname, entry->d_name);
            add_file(filepath);
        }
    }
    closedir(d);
}

void add_all() {
    rec_search("."); 
}

int add(const char *files[], size_t files_len) {
    if (strcmp(files[2], ".") == 0) {
        add_all();
        return 0;
    }

    for (int i = 2; i < files_len; i++) {
        add_file(files[i]); 
    }
    return 0;
}

